package com.gasmonitor.config;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import org.springframework.context.annotation.Configuration;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;import java.lang.reflect.Method;import java.util.concurrent.Executor;import java.util.concurrent.ThreadPoolExecutor;/** * Created by saplmm on 2017/7/29. */@Configurationpublic class AsyncTaskExecutePool implements AsyncConfigurer {    private Logger log = LoggerFactory.getLogger(AsyncTaskExecutePool.class);    @Override    public Executor getAsyncExecutor() {        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        executor.setCorePoolSize(100);        executor.setMaxPoolSize(100);        executor.setQueueCapacity(100);        executor.setKeepAliveSeconds(1000);        executor.setThreadNamePrefix("taskExecutor-");        // rejection-policy：当pool已经达到max size的时候，如何处理新任务        // CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        executor.initialize();        return executor;    }    @Override    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {// 异步任务中异常处理        return new AsyncUncaughtExceptionHandler() {            @Override            public void handleUncaughtException(Throwable arg0, Method arg1, Object... arg2) {                log.error("==========================" + arg0.getMessage() + "=======================", arg0);                log.error("exception method:" + arg1.getName());            }        };    }}